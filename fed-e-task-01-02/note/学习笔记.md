### 函数式编程与javascript性能优化

#### 任务一：函数式编程范式

##### 1.为什么学习函数式编程：
+ 1）函数式编程是随着react的流行收到越来越多的关注，且react也由以前的class组件到现在的推荐大家用函数组件
+ 2）Vue3也开始拥抱函数式编程
+ 3）函数式编程可以抛弃this
+ 4）打包过程中可以更好的利用tree shaking 过滤无用代码
+ 5）方便测试、方便并行处理
+ 6）有很多库可以帮助我们进行函数式开发：loadsh、underscore、ramda

##### 2.什么是函数式编程
+ 编程范式：面向过程编程、面向对象编程和函数式编程
+ 1）面向过程编程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
+ 2）面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系
+ 3）函数式编程：把现实事件的事物和事物之间的***联系***抽象到程序世界（对运算过程进行抽象）：
+     a）x->f(联系、映射)->y,y=f(x)
+     b）函数式编程中的函数指的不是程序中的函数（方法），而是数学中的函数即映射关系，例如：y=sin(x),x和y的关系
+     c）相同的输入始终要得到相同的输出（***纯函数***）
+     d）函数式编程用来描述数据（函数之间的映射）

##### 3.函数是一等公民
+ 定义：
+     1.函数可以存储在变量中
+     2.函数作为参数
+     3.函数作为返回值
+ 在jacascript中**函数就是一个普通的对象（可以通过 new Function()）**,我们可以把函数存储到变量/数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过 new Function('alert()1') 来构造一个新的函数。

##### 4.高阶函数
+ 高阶函数：可以把函数作为参数传递给另一个函数，也可以把函数作为另一个函数的返回结果
+ 高阶函数的意义：
+       1）抽象可以帮我们屏蔽细节
+       2）高阶函数是用来抽象通用的问题

##### 5.闭包
+ 闭包（Closure):函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包，可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员（延长了外部函数内部变量的作用域范围）。
+ 闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，~~ 但是堆上的作用域成员 ~~因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员

##### 6.纯函数:相同的输入永远会得到相同的输出，而且没有任何可观察的副作用
+ 纯函数就类似数学中的函数（用来描述输入和输出之间的关系），y=f(x)
+ loadsh是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法
+ 数组的slice和splice分别是：纯函数和不纯的函数
+       slice 返回数组中的指定部分，不会改变原数组
+       splice 对数组进行操作返回该数组，会改变原数组
+ 函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）
+ 我们可以把一个函数的执行结果交给另一个函数去处理
+ 纯函数的好处：
+       可缓存：纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来
+       可移植性：可以意味着把函数序列化（serializing）并通过 socket 发送。也可以意味着代码能够在 web workers 中运行。总之，可移植性是一个非常强大的特性。
+       可测试：纯函数让测试更方便
+       并行处理：在多线程环境下并行操作共享的内存数据很可能会出现意外情况，纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行陈函数
+ 副作用：如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降，不适合扩展和可重用性，同时副作用会给程序中带来安全隐患和不确定性，但是副作用不能完全禁止，尽可能控制它们在可控范围内发生。副作用来源如下（如下这些只是一部分）：
+       1、更改文件系统
+       2、往数据库插入记录
+       3、发送一个 http 请求
+       4、可变数据
+       5、打印/log
+       6、获取用户输入
+       7、DOM 查询
+       8、访问系统状态

##### 7.柯里化
+ 柯里化的定义：当一个函数有多个参数的时候先传递一部分的参数调用它（这部分参数以后永远不变），然后返回一个新的函数接收剩余的参数，返回结果。
+ 柯里化总结：
+       1.柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
+       2.这是一种对函数参数的缓存
+       3.让函数变得更灵活，让函数的力度更小
+       4.可以把多元函数转化成一元函数，可以组合使用函数产生强大的功能

##### 8.函数组合
+ 函数组合（compose）:如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数
+       1.函数就像是数据的管道，函数组合就是把这些管道连起来，让数据穿过多个管道形成最终结果
+       2.函数组合默认是从右到左执行

##### 9.PointFree
+ PointFree: 我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数
+     1.不需要指明处理的数据
+     2.只需要合成运算的过程
+     3.需要定义一些辅助的基本运算函数

##### 10.Functor
+ 为什么学习函子：到目前为止已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用控制在可控的范围内、异常处理、异步操作等。
+ 什么是Functor:
+     1、容器：包含值和值的变形关系（这个变形关系就是函数）
+     2、函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理（变形关系）
+ 总结：
+     1.函数式编程的运算不直接操作值，而是由函子完成
+     2.函子就是一个实现了map契约的对象
+     3.我们可以把函子想象成一个盒子，这个盒子里封装了一个值
+     4.想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理
+     5.最终map方法返回一个包含新值的盒子（函子）

##### 11.IO函子
+ IO函子中的_value是一个函数，这里是把函数作为值来处理
+ IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），包装当前的操作为纯操作
+ 把不纯的操作交给调用者来处理

##### 12.Pointed函子
+ Pointed函子是实现了 of 静态方法的函子
+ of 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文 Context (把值放到容器中，使用map来处理值)



#### 任务二：javascript性能优化

##### javascript内存管理：
+ 内存：由可读写单元组成，表示一片可操作的空间
+ 管理：人为的去操作一片空间的申请、使用和释放
+ 内存管理：开发者主动申请空间、使用空间、释放空间
+ 管理流程：申请——使用——释放

##### javascript中的垃圾
+ javascript中内存管理是自动的
+ 对象不再被引用时是垃圾
+ 对象不能从根本上访问到时是垃圾

##### javascript中的可达对象
+ 可以访问到的对象就是可达对象（引用、作用域链）
+ 可达的标准就是从根本出发是否能够被找到
+ js中的根就可以理解为是全局变量对象 

##### GC算法是什么
+ 常见GC算法：引用计数、标记清除、标记整理和分代回收
+ GC是一种机制，垃圾回收器完成具体的工作
+ 工作的内筒就是查找垃圾释放空间、回收空间
+ 算法就是工作时查找和回收所遵循的规则
 
##### 引用技术算法
+ 核心思想：设置引用数，判断当前引用数是否为0
+ 引用计数器
+ 引用关系改变时修改引用数字
+ 引用数字为0时立即回收

##### 引用计数算法的优点
+ 发现垃圾时立即回收
+ 最大限度减少程序暂停：应用程序运行过程中必然会堆内存进行消耗，而垃圾回收机制可以最大限度的减少内存爆满。

##### 引用算法的缺点
+ 无法回收循环引用的对象
+ 时间开销大，资源消耗大

##### 标记清除算法
+ 没明白的地方：标记清除算法中释放的对象空间会添加到空闲链表中（不会添加到内存中），此时会出现连续的分块（可以合并）和不连续的分块，而不连续的分块则再分配。
+ 核心思想：分标记和清除二个阶段完成
+ 实现：
+     1、遍历所有对象找标记活动对象
+     2、遍历所有对象清除没有标记对象
+     3、回收相应的空间
+ 优点：解决了对象循环引用的回收操作，可以回收循环引用的对象
+ 缺点：空间碎片化，浪费空间，不会立即回收垃圾对象

##### 标记整理算法原理
+ 标记整理可以看作是标记清除的增强
+ 标记阶段的操作和标记清除一致
+ 清除阶段会先执行整理，移动对象位置
+ 优点：配合标记清除算法将释放出来不连续的分块整理成连续的分块，减少碎片化空间，
+ 缺点：不会立即回收垃圾对象

##### 认识V8
+ V8是一款主流的javascript执行引擎
+ V8采用即时编译
+ V8内存设限

##### V8垃圾回收策略
+ 采用分代回收的思想
+ 内存分为新生代、老生代
+ 针对不同对象采用不同算法

##### V8中常用的GC算法
+     1、分代回收
+     2、空间复制
+     3、标记清除
+     4、标记整理
+     5、标记增量（提高效率）

##### V8内存分配
+ V8内存空间一分为二
+ 小空间用于存储新生代对象（32M | 16M）
+ 新生代指的是存活时间较短的对象（例如局部作用域内的变量）
+ 新生代对象回收的实现：
+     1、回收过程采用复制算法 + 标记整理
+     2、新生代内存区分为二个等大小空间
+     3、使用空间为From,空闲空间为To
+     4、活动对象存储于From空间
+     5、标记整理后将活动对象拷贝至To
+     6、From与To交换空间完成释放
+ 新生代对象回收细节说明：
+     1、拷贝过程中可能出现晋升
+     2、晋升就是将新生代对象移动至老生代
+     3、一轮GC还存活的新生代对象需要晋升
+     4、To空间的使用率不超过25%
+ 老生代对象说明：老生代对象存放在右侧老生代区域，64位操作系统1.4G，32操作系统700M，老年代对象就是指存活时间较长的对象。
+ 老生代对象回收实现：
+     1、主要采用标记清除、标记整理、增量标记算法
+     2、首先使用标记清除完成垃圾空间的回收
+     3、采用标记整理进行空间优化
+     4、采用增量标记进行效率优化
+ 新生代对象和老生代对象回收细节对比：
+     1、新生代区域垃圾回收使用空间换时间
+     2、老生代区域垃圾回收不适合复制算法


##### Performance工具使用
+ 界定内存问题的标准
  	内存泄漏：内存使用持续升高
  	内存膨胀：在多数设备上都存在性能问题
  	频繁垃圾回收：通过内存变化图进行分析
+ Timeline时序图记录
+ 堆快照查找分离DOM
  	什么是分离DOM
  		界面元素存活在DOM树上
  		垃圾对象时的DOM节点
  		分离状态的DOM节点
  ```javascript
  const btn = document.getElementById('btn')
  var tmpEle
  btn.onclick = function () {
    var ul = document.createElement('ul')
    for (var i = 0; i < 10; i++) {
      var li = document.createElement('li')
      ul.appendChild(li)
    }
    tmpEle = ul
    ul = null // 优化处理，回收分离DOM
  }
  ```
+ 判断是否存在频繁的垃圾回收
  + 为什么要确定频繁垃圾回收
    + GC工作时应用程序是停止的
    + 频繁且过长的GC会导致应用卡死
    + 用户使用中感知应用卡顿
  + 确定频繁的垃圾回收
    + Timeline中频繁的上升下降
    + 任务管理器中数据频繁的增加减小








### 问题总结：
+     1、应该是先把From标记整理后拷贝到To,释放From空间，然后To空间GC，GC完了后晋升，那这个都晋升了，To空间里是不是都没有新生代对象了？
+     2、
      ``` javascript
        function memoize(f) {
          let cache = {}
          return function() {
            let key = JSON.stringify(arguments)
            return cache[key]=cache[key] || f.apply(f,arguments)
          }
        }
      ```
      这里的apply方法的用意是什么？没理解
+     3、函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）。这句话是怎么理解的？





